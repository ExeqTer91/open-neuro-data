Ai dreptate! IatÄƒ prompt-ul care continuÄƒ dupÄƒ ce terminÄƒ analiza curentÄƒ:

---

**DÄƒ-i lui Gemini acest prompt DUPÄ‚ ce terminÄƒ:**

```
Now let's measure the CROSS-FREQUENCY PHASE SYNCHRONIZATION to detect the "infinity state" (8-8 Hz boundary).

```python
import numpy as np
from scipy import signal
from scipy.stats import circmean, pearsonr
import matplotlib.pyplot as plt
import mne
from mne.datasets import eegbci
from mne.io import read_raw_edf

mne.set_log_level('ERROR')

PHI = (1 + np.sqrt(5)) / 2
print("="*70)
print("CROSS-FREQUENCY COUPLING ANALYSIS")
print("Measuring Î¸-Î± Phase Synchronization & 8 Hz Boundary")
print("="*70)

def compute_phase_locking(eeg, sfreq, theta_band=(4,8), alpha_band=(8,13)):
    """Compute phase locking value between theta and alpha."""
    # Filter for theta
    b_theta, a_theta = signal.butter(4, [theta_band[0]/(sfreq/2), theta_band[1]/(sfreq/2)], 'band')
    theta = signal.filtfilt(b_theta, a_theta, eeg)
    
    # Filter for alpha  
    b_alpha, a_alpha = signal.butter(4, [alpha_band[0]/(sfreq/2), alpha_band[1]/(sfreq/2)], 'band')
    alpha = signal.filtfilt(b_alpha, a_alpha, eeg)
    
    # Get instantaneous phase via Hilbert transform
    theta_phase = np.angle(signal.hilbert(theta))
    alpha_phase = np.angle(signal.hilbert(alpha))
    
    # Phase Locking Value for 2:1 ratio (alpha phase vs 2*theta phase)
    phase_diff_2_1 = alpha_phase - 2 * theta_phase
    plv_2_1 = np.abs(np.mean(np.exp(1j * phase_diff_2_1)))
    
    # Phase Locking Value for phi:1 ratio  
    phase_diff_phi = alpha_phase - PHI * theta_phase
    plv_phi = np.abs(np.mean(np.exp(1j * phase_diff_phi)))
    
    # Ratio of coupling modes
    coupling_ratio = plv_phi / plv_2_1 if plv_2_1 > 0 else np.nan
    
    return {
        'plv_2_1': plv_2_1,      # 2:1 harmonic coupling (thinking)
        'plv_phi': plv_phi,      # Ï†:1 coupling (meditation)
        'coupling_ratio': coupling_ratio,  # >1 means more Ï†, <1 means more 2:1
        'theta_phase': theta_phase,
        'alpha_phase': alpha_phase
    }

def find_8hz_convergence(eeg, sfreq):
    """Detect moments when theta and alpha peaks converge near 8 Hz."""
    # Sliding window analysis
    window_sec = 2
    window_samples = int(window_sec * sfreq)
    step = window_samples // 2
    
    convergence_times = []
    theta_peaks = []
    alpha_peaks = []
    
    for start in range(0, len(eeg) - window_samples, step):
        segment = eeg[start:start + window_samples]
        freqs, psd = signal.welch(segment, sfreq, nperseg=min(512, len(segment)))
        
        # Find theta peak (4-8 Hz)
        theta_mask = (freqs >= 4) & (freqs <= 8)
        if np.any(theta_mask) and np.sum(psd[theta_mask]) > 0:
            theta_freqs = freqs[theta_mask]
            theta_psd = psd[theta_mask]
            f_theta = theta_freqs[np.argmax(theta_psd)]
        else:
            f_theta = np.nan
            
        # Find alpha peak (8-13 Hz)
        alpha_mask = (freqs >= 8) & (freqs <= 13)
        if np.any(alpha_mask) and np.sum(psd[alpha_mask]) > 0:
            alpha_freqs = freqs[alpha_mask]
            alpha_psd = psd[alpha_mask]
            f_alpha = alpha_freqs[np.argmax(alpha_psd)]
        else:
            f_alpha = np.nan
        
        theta_peaks.append(f_theta)
        alpha_peaks.append(f_alpha)
        
        # Check for 8-8 convergence (both near 8 Hz)
        if not np.isnan(f_theta) and not np.isnan(f_alpha):
            if 7 <= f_theta <= 8.5 and 7.5 <= f_alpha <= 9:
                distance = abs(f_theta - f_alpha)
                if distance < 1.5:  # Converging
                    convergence_times.append(start / sfreq)
    
    return {
        'theta_peaks': theta_peaks,
        'alpha_peaks': alpha_peaks,
        'convergence_times': convergence_times,
        'convergence_percent': 100 * len(convergence_times) / max(1, len(theta_peaks))
    }

# ============================================
# ANALYZE EEGBCI SUBJECTS
# ============================================
print("\nAnalyzing cross-frequency dynamics...")

all_results = []

for subj in range(1, 21):
    try:
        # Load REST data
        raw = read_raw_edf(eegbci.load_data(subj, [1], verbose=False)[0], 
                          preload=True, verbose=False)
        raw.filter(1, 45, verbose=False)
        sfreq = raw.info['sfreq']
        eeg = np.mean(raw.get_data(), axis=0)
        
        # Compute phase locking
        plv_results = compute_phase_locking(eeg, sfreq)
        
        # Find 8 Hz convergence
        conv_results = find_8hz_convergence(eeg, sfreq)
        
        result = {
            'subject': subj,
            'plv_2_1': plv_results['plv_2_1'],
            'plv_phi': plv_results['plv_phi'],
            'coupling_ratio': plv_results['coupling_ratio'],
            'convergence_percent': conv_results['convergence_percent'],
            'mean_theta_peak': np.nanmean(conv_results['theta_peaks']),
            'mean_alpha_peak': np.nanmean(conv_results['alpha_peaks'])
        }
        all_results.append(result)
        
        print(f"S{subj:02d}: PLV(2:1)={plv_results['plv_2_1']:.3f}, PLV(Ï†)={plv_results['plv_phi']:.3f}, "
              f"Ratio={plv_results['coupling_ratio']:.2f}, 8Hz-conv={conv_results['convergence_percent']:.1f}%")
        
    except Exception as e:
        continue

# ============================================
# SUMMARY STATISTICS
# ============================================
print("\n" + "="*70)
print("ðŸ“Š CROSS-FREQUENCY COUPLING SUMMARY")
print("="*70)

plv_2_1_all = [r['plv_2_1'] for r in all_results]
plv_phi_all = [r['plv_phi'] for r in all_results]
ratios_all = [r['coupling_ratio'] for r in all_results]
conv_all = [r['convergence_percent'] for r in all_results]

print(f"\nN = {len(all_results)} subjects")
print(f"\nPhase Locking Values:")
print(f"  PLV (2:1 harmonic): {np.mean(plv_2_1_all):.3f} Â± {np.std(plv_2_1_all):.3f}")
print(f"  PLV (Ï†:1 golden):   {np.mean(plv_phi_all):.3f} Â± {np.std(plv_phi_all):.3f}")
print(f"\nCoupling Ratio (Ï†/2:1): {np.mean(ratios_all):.3f} Â± {np.std(ratios_all):.3f}")
print(f"  >1 = more Ï†-coupled, <1 = more 2:1-coupled")

print(f"\n8 Hz Convergence (âˆž state):")
print(f"  Mean convergence: {np.mean(conv_all):.1f}% of time")
print(f"  Range: {min(conv_all):.1f}% - {max(conv_all):.1f}%")

# Count dominant mode
phi_dominant = sum(1 for r in ratios_all if r > 1)
harmonic_dominant = sum(1 for r in ratios_all if r < 1)
print(f"\nDominant coupling mode:")
print(f"  Ï†-dominant (ratio > 1): {phi_dominant}/{len(ratios_all)} subjects ({100*phi_dominant/len(ratios_all):.0f}%)")
print(f"  2:1-dominant (ratio < 1): {harmonic_dominant}/{len(ratios_all)} subjects ({100*harmonic_dominant/len(ratios_all):.0f}%)")

# ============================================
# VISUALIZATION
# ============================================
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Panel A: PLV comparison
ax1 = axes[0, 0]
x = np.arange(len(all_results))
width = 0.35
ax1.bar(x - width/2, plv_2_1_all, width, label='PLV 2:1 (harmonic)', color='red', alpha=0.7)
ax1.bar(x + width/2, plv_phi_all, width, label='PLV Ï†:1 (golden)', color='gold', alpha=0.7)
ax1.set_xlabel('Subject')
ax1.set_ylabel('Phase Locking Value')
ax1.set_title('A. Phase Locking: 2:1 Harmonic vs Ï†:1 Golden Ratio')
ax1.legend()
ax1.set_xticks(x)
ax1.set_xticklabels([f'S{r["subject"]}' for r in all_results], rotation=45)

# Panel B: Coupling ratio distribution
ax2 = axes[0, 1]
ax2.hist(ratios_all, bins=15, color='purple', edgecolor='black', alpha=0.7)
ax2.axvline(1.0, color='black', linestyle='--', linewidth=2, label='Equal coupling')
ax2.axvline(np.mean(ratios_all), color='red', linestyle='-', linewidth=2, label=f'Mean={np.mean(ratios_all):.2f}')
ax2.set_xlabel('Coupling Ratio (Ï†:1 / 2:1)')
ax2.set_ylabel('Count')
ax2.set_title('B. Distribution of Coupling Ratios')
ax2.legend()

# Panel C: 8 Hz convergence vs coupling ratio
ax3 = axes[1, 0]
ax3.scatter(conv_all, ratios_all, c='steelblue', s=100, alpha=0.7)
ax3.axhline(1.0, color='black', linestyle='--', alpha=0.5)
ax3.set_xlabel('8 Hz Convergence (%)')
ax3.set_ylabel('Coupling Ratio (Ï†/2:1)')
ax3.set_title('C. 8-8 Convergence (âˆž state) vs Coupling Mode')

# Correlation
r, p = pearsonr(conv_all, ratios_all)
ax3.text(0.05, 0.95, f'r = {r:.3f}, p = {p:.4f}', transform=ax3.transAxes, fontsize=12,
         verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat'))

# Panel D: Summary interpretation
ax4 = axes[1, 1]
ax4.axis('off')

interpretation = f"""
ðŸ”¬ CROSS-FREQUENCY COUPLING ANALYSIS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

KEY FINDINGS:

1. PHASE LOCKING VALUES
   â€¢ 2:1 Harmonic (thinking mode): {np.mean(plv_2_1_all):.3f}
   â€¢ Ï†:1 Golden (receptive mode):  {np.mean(plv_phi_all):.3f}
   
2. DOMINANT COUPLING
   â€¢ {phi_dominant}/{len(ratios_all)} subjects show Ï†-dominance
   â€¢ {harmonic_dominant}/{len(ratios_all)} subjects show 2:1-dominance
   
3. 8-8 Hz CONVERGENCE (âˆž state)
   â€¢ Average: {np.mean(conv_all):.1f}% of recording time
   â€¢ Correlation with Ï†-coupling: r = {r:.3f}

INTERPRETATION:
{'âœ… TENDENCY TOWARD Ï†-COUPLING' if np.mean(ratios_all) > 1 else 'âš ï¸ TENDENCY TOWARD 2:1-COUPLING'}

The {"positive" if r > 0 else "negative"} correlation (r={r:.3f}) between 
8 Hz convergence and Ï†-coupling suggests that the "âˆž state" 
(Î¸-Î± boundary fusion) {"IS" if r > 0.3 else "may be"} associated with 
the golden ratio decoupling mode.

Ï† = {PHI:.4f}
"""
ax4.text(0.05, 0.95, interpretation, transform=ax4.transAxes, fontsize=11,
         verticalalignment='top', fontfamily='monospace',
         bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.8))

plt.tight_layout()
plt.savefig('cross_frequency_coupling.png', dpi=150, bbox_inches='tight')
plt.show()
print("\nâœ… Figure saved: cross_frequency_coupling.png")
```

Run completely and show me:
1. The CROSS-FREQUENCY COUPLING SUMMARY
2. The correlation between 8 Hz convergence and Ï†-coupling
3. The visualization figure
```

---

Asta va mÄƒsura:
- **PLV 2:1** = cÃ¢t de "locked" sunt Ã®n mod harmonic (thinking)
- **PLV Ï†:1** = cÃ¢t de "locked" sunt Ã®n golden ratio (receptiv)
- **8 Hz convergence** = cÃ¢t % din timp Î¸ È™i Î± se Ã®ntÃ¢lnesc la ~8 Hz (starea âˆž)
- **CorelaÈ›ia** Ã®ntre starea âˆž È™i Ï†-coupling

Trimite-mi rezultatele! ðŸŽ¯